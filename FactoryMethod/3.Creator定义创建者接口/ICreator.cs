using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FactoryMethod
{
    // 定义创建者接口

    //定义创建者接口时使用抽象类而不是接口（interface）的原因主要有以下几点：

    //1.成员默认实现：抽象类可以提供成员的默认实现，而接口只能定义成员的签名。这意味着在抽象类中，你可以提供一个FactoryMethod的默认实现，而子类可以选择覆盖它或者直接使用默认实现。这样可以减少代码的重复，并且提供更多的灵活性
    //。

    //2.包含非抽象成员：抽象类可以包含非抽象成员，即那些不需要在子类中被重写的成员。这允许你将一些通用的逻辑放在抽象类中，而子类只需要关注特定的实现细节
    //。

    //3.更好的封装：抽象类提供了更好的封装性，因为它可以包含私有成员和保护成员。这些成员在接口中是不被允许的。通过使用抽象类，你可以隐藏一些实现细节，只暴露必要的接口给子类
    //。

    //4.强制子类实现：虽然接口也可以强制子类实现其成员，但抽象类提供了一种更灵活的方式来强制子类实现特定的成员。你可以在抽象类中提供一个抽象方法，也可以提供一个虚拟方法并提供默认实现，这样子类可以选择是否覆盖这个方法
    //。

    //5.类型安全：使用抽象类作为创建者接口可以提供更好的类型安全。因为抽象类是具体的类，所以你可以确保所有的实现都是基于同一个基类，这有助于保持代码的一致性和减少类型转换的错误
    //。

    //6.设计意图清晰：使用抽象类来定义创建者接口可以更清晰地表达设计意图。它表明这是一个基类，所有的具体创建者都应该继承自这个基类，并且可能共享一些通用的逻辑和成员
    //。
    public abstract class ICreator
    {
        public abstract IShape CreateShape();
    }
}
